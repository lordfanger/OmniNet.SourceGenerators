using System.Collections.Concurrent;
using System.Reflection;

namespace OmniNet.SourceGenerators.Core;

/// <summary>
/// Helper to create handles to attributes generated and used by source generator.
/// <para>Attributes must be included as resource inside defining assembly with path starting at <c>Template.Attributes</c> without any other directory.</para>
/// <para>The helper holds all found attributes cached and should process assembly resources only once.</para>
/// </summary>
internal class AssemblyGeneratorAttributesHelper
{
    private static readonly ConcurrentDictionary<string, AssemblyGeneratorAttributesHelper> _attributesByAssembly = new();
    private readonly IDictionary<string, GeneratorAttribute> _attributes;

    /// <summary>
    /// Construct helper for cached attributes stored in assembly resources that can by used and generated by source generator.
    /// </summary>
    /// <param name="assembly">Assembly whore resources will be processed to get stored attributes sources.</param>
    private AssemblyGeneratorAttributesHelper(Assembly assembly)
    {
        var assemblyName = assembly.GetName().Name;
        var attributes = new Dictionary<string, GeneratorAttribute>();
        var resources = assembly.GetManifestResourceNames();
        var templatePath = $"{assemblyName}.Template";
        var templateAttributesPath = $"{assemblyName}.Template.Attributes";

        foreach (var resource in resources.Where(r => r.StartsWith(templatePath) && r.EndsWith(".cs")))
        {
            if (!resource.StartsWith(templateAttributesPath)) continue;

            var stream = assembly.GetManifestResourceStream(resource);
            if (stream == null)
            {
                continue; 
            }

            using (stream)
            {
                using var reader = new StreamReader(stream);
                var content = reader.ReadToEnd();

                // Type name is constructed from file name (any subdirectory will be treated as delimiter '.') without .cs extension.
                // Eg. for MyAssembly.Template.Attributes.MyGeneratorAttribute.cs entry the final type name would be MyGeneratorAttribute
                var typeName = resource[(templateAttributesPath.Length + 1)..^".cs".Length];
                var generatorAttribute = new GeneratorAttribute($"Attributes/{typeName}.cs", content);
                attributes.Add(typeName, generatorAttribute);
            }
        }

        _attributes = attributes;
    }

    /// <summary>
    /// Creates handle to cached attribute's source code.
    /// </summary>
    /// <typeparam name="TAttribute">Type of attribute generated and used by source generator.</typeparam>
    /// <returns><inheritdoc cref="IGeneratorAttribute" path="/summary"/></returns>
    public static IGeneratorAttribute CreateAttribute<TAttribute>()
        where TAttribute : Attribute
    {
        var attributes = GetAttributes<TAttribute>();
        var attributeName = typeof(TAttribute).Name;
        var generatorAttribute = attributes._attributes[attributeName];
        var attribute = new GeneratorAttribute<TAttribute>(generatorAttribute);
        return attribute;
    }

    private static AssemblyGeneratorAttributesHelper GetAttributes<TAttribute>()
        where TAttribute : Attribute
    {
        var assembly = typeof(TAttribute).Assembly;
        var name = assembly.FullName;
        if (_attributesByAssembly.TryGetValue(name, out var attributes))
        {
            return attributes;
        }

        attributes = _attributesByAssembly.GetOrAdd(name, _ => new AssemblyGeneratorAttributesHelper(assembly));
        return attributes;
    }

    /// <summary>
    /// Cached attribute source code.
    /// </summary>
    private class GeneratorAttribute(string generatedFilePath, string sourceCode)
    {
        /// <summary>
        /// Relative path of generated attribute by source generator.
        /// </summary>
        public string GeneratedFilePath { get; } = generatedFilePath;

        /// <summary>
        /// Generated source code.
        /// </summary>
        public string SourceCode { get; } = sourceCode;
    }

    /// <summary>
    /// Handle for cached attribute source code of concrete attribute.
    /// </summary>
    private class GeneratorAttribute<TAttribute> : IGeneratorAttribute
        where TAttribute : Attribute
    {
        private readonly GeneratorAttribute _attribute;

        /// <inheritdoc cref="GeneratorAttribute{TAttribute}"/>
        /// <param name="attribute"><inheritdoc cref="GeneratorAttribute"/></param>
        public GeneratorAttribute(GeneratorAttribute attribute)
        {
            _attribute = attribute;
        }

        /// <inheritdoc />
        public string GeneratedFilePath => _attribute.GeneratedFilePath;

        /// <inheritdoc />
        public string SourceCode => _attribute.SourceCode;

        /// <inheritdoc />
        public string TypeFullName { get; } = typeof(TAttribute).FullName ?? typeof(TAttribute).Name;

        /// <inheritdoc />
        public string TypeName { get; } = typeof(TAttribute).Name;
    }
}